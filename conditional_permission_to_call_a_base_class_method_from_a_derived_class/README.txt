Проблематика примера:
    У нас есть два класса (SharedImage - базовый класс, StaticImage - производный класс). 
StaticImage содержит в себе массив с данными, а SharedImage получает указатель на эти данные в своем конструкторе. 
Тут имеется одна концептуальная проблема, то что в своем конструкторе StaticImage вызывает сначала конструктор 
SharedImage, так как он от него наследуется, и передает в этот конструктор (SharedImage) указатель на массив с 
данными, чей конструктор отработает только после того как сконструируется сам SharedImage. На лицо у нас 
проблема курица и яйца. Очевидное решение это в конструктор SharedImage передать что-то типа NULL/nullptr, затем 
после того как в констуркторе StaticImage в списке инициализации отработает конструктор для массива передать на 
него указатель через какой нибудь метод базового класса(в нашем примере это setData). Данный метод хотелось бы 
ограничить определнным кругом лиц в использовании. Для этого он был сделать шаблонным, т.е в SharedImage его пока 
нету, пока кто-то его не конкретизирует. Конкретизация должна происходить на уровне конструктора StaticImage 
("для большей типа безопасности"). Так же в самом шаблонном методе идет проверка какой тип его вызвал.

Рассмотрим метод setData более подробно:
    Данный метод является шаблонным как было уже сказано, поэтому его нету, пока его не конкретизировали, а внутри 
себя при конкретизации он проверяет что его конкретизировал не сам класс, а его производный(что бы избезать вызова 
не от того класса). Данный метод принимает в шаблонных параметрах сам тип вызывающего, тип его внутреннего 
класса-хранилища массива и указатель на метод-класса этого хранилища. Внутри этого метода после прохождения всех 
проверок что мы вызваны от нужного типа происходит вызов метода класса через переданный класс. Так как вызов 
происходит с помощью указателя на метод, то нужно еще передать и this класса для осуществления этого вызова.

Ясно что это надуманный пример, но техника весьма может оказаться полезной в схожих примерах, например нам нужно 
задать права на вызовы енкторых методов от конкретных классов или после срабатывания определенного условия.
В общем идея илюстрирующая данный пример может пригодиться.
